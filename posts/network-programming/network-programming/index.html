<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 网络编程</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css><style>body{font-family:source han serif cn vf}</style></head><body class="bg:fade-84@dark font:fade-16@dark"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;}
_:where(th){font:fade-78;_font:14;_text:left}
_:where(th,p_code,li_code,a,mark){font:semibold}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-30;_my:1em}"><h1 id=linux-网络编程>Linux 网络编程</h1><h2 id=网络字节序>网络字节序</h2><h3 id=大小端>大小端</h3><p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。</p><ul><li>大端序（big endian）：<strong>最高位</strong>有效字节存储在<strong>低内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>高内存地址</strong>。</li><li>小端序（little endian）：<strong>最高位</strong>有效字节存储在<strong>高内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>低内存地址</strong>。</li></ul><hr><p>对于一个 4 字节整数 <code>0x01020304</code>，大小端序存储方式分别如下：</p><pre tabindex=0><code>地址:  0   1   2   3  （大端序保存）
      01  02  03  04
</code></pre><pre tabindex=0><code>地址:  0   1   2   3  （小端序保存）
      04  03  02  01
</code></pre><hr><p>可以使用下边的方法判断机器的字节序：</p><ol><li>通过 <code>endian.h</code> 提供的 <code>BYTE_ORDER</code> 宏。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;endian.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> BYTE_ORDER <span style=color:#f92672>==</span> BIG_ENDIAN;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> BYTE_ORDER <span style=color:#f92672>==</span> LITTLE_ENDIAN;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>将 <code>uint16_t</code> 类型的数字转为 <code>char *</code>，通过高字节和低字节进行判断。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) (<span style=color:#f92672>&amp;</span>val))[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) (<span style=color:#f92672>&amp;</span>val))[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>和方法 2 类似，利用的是 <code>union</code> 相同的内存位置存储不同的数据类型。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>union</span> endian {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> bytes[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> endian en{};
</span></span><span style=display:flex><span>    en.val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> en.bytes[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> endian en{};
</span></span><span style=display:flex><span>    en.val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> en.bytes[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x02</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>为什么有两种不同的字节序？</p><blockquote><p><strong>大端序</strong>是人类最熟悉的读写方法，从左向右处理。</p><p><strong>小端序</strong>更利于计算机处理，因为计算都是从低位开始的，先处理低位字节，效率比较高。</p></blockquote><h3 id=网络字节序-1>网络字节序</h3><p>如果通信双方采用不同的架构，收发数据后进行解析时会发生问题。如：大端序机器 A 发送 <code>0x01020304</code> 到小端序机器 B 时，B 以小端序方式解析该数字为 <code>0x04030201</code>。</p><p>为解决上边问题，网络传输数据时，通信双方需要约定统一方式，把此约定叫做<strong>网络字节序</strong>（network byte order）。</p><blockquote><p>网络字节序规定使用<strong>大端序</strong>，大多数网络协议（例如 TCP/IP 协议族）规定了网络字节序采用<strong>大端序</strong>。</p></blockquote><p>因此，小端序发送数据时，需要先转为大端序。</p><h3 id=字节序转换>字节序转换</h3><p>下边函数用于字节序的相互转换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>htonl</span>(<span style=color:#66d9ef>uint32_t</span> hostlong);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>htons</span>(<span style=color:#66d9ef>uint16_t</span> hostshort);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>ntohl</span>(<span style=color:#66d9ef>uint32_t</span> netlong);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>ntohs</span>(<span style=color:#66d9ef>uint16_t</span> netshort);
</span></span></code></pre></div><p>函数名中的 <code>h</code> 表示主机（host）字节序，<code>n</code> 表示网络（network）字节序；<code>s</code> 表示 <code>short</code> 类型，<code>l</code> 表示 <code>long</code> 类型。</p><h2 id=网络地址族>网络地址族</h2><h3 id=网络地址>网络地址</h3><p>网络地址分为 IPv4 和 IPv6，分别使用 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 结构体表示。</p><h4 id=sockaddr_in>sockaddr_in</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sa_family_t</span>    sin_family; <span style=color:#75715e>/* address family: AF_INET */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in_port_t</span>      sin_port;   <span style=color:#75715e>/* port in network byte order */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> in_addr sin_addr;   <span style=color:#75715e>/* internet address */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Pad to size of `struct sockaddr&#39;.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> sin_zero[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Internet address */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> in_addr {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span>       s_addr;     <span style=color:#75715e>/* address in network byte order */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>sin_family</code>：在 IPv4 中设为 <code>AF_INET</code>。</li><li><code>sin_port</code>：<strong>网络字节序</strong>保存的端口（0～65535）。</li><li><code>sin_addr</code>：<strong>网络字节序</strong>保存的 32 位 IP 地址信息。</li><li><code>sin_zero</code>：使 <code>sockaddr_in</code> 和 <code>sockaddr</code> 结构体大小保持一致而插入的填充位，需手动设为 0。</li></ul><blockquote><p><a href=https://man7.org/linux/man-pages/man7/ip.7.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man7/ip.7.html</a></p></blockquote><h4 id=sockaddr_in6>sockaddr_in6</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in6 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sa_family_t</span>     sin6_family;   <span style=color:#75715e>/* AF_INET6 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in_port_t</span>       sin6_port;     <span style=color:#75715e>/* port number */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span>        sin6_flowinfo; <span style=color:#75715e>/* IPv6 flow information */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> in6_addr sin6_addr;     <span style=color:#75715e>/* IPv6 address */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span>        sin6_scope_id; <span style=color:#75715e>/* Scope ID (new in Linux 2.4) */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> in6_addr {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>   s6_addr[<span style=color:#ae81ff>16</span>];   <span style=color:#75715e>/* IPv6 address */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>sin6_family</code>：在 IPv6 中总设为 <code>AF_INET6</code>。</li><li><code>sin6_port</code>：<strong>网络字节序</strong>保存的端口（0～65535）。</li><li><code>sin6_flowinfo</code>：IPv6 流信息（不广泛使用）。</li><li><code>sin6_addr</code>：表示 IPv6 地址的结构体，定义为 <code>struct in6_addr</code>。</li><li><code>sin6_scope_id</code>：范围标识符（用于链路本地和站点本地地址）。</li></ul><blockquote><p><a href=https://man7.org/linux/man-pages/man7/ipv6.7.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man7/ipv6.7.html</a></p></blockquote><h3 id=in_addr-和-in6_addr>in_addr 和 in6_addr</h3><h4 id=in_addr>in_addr</h4><p>我们比较熟悉的 IPv4 地址表示方法为<strong>点分十进制表示法</strong>，如：201.123.235.213。</p><p>而 <code>in_addr</code> 结构体使用 <code>uint32_t</code> 保存 IPv4 地址，我们需要将字符串形式的 IPv4 地址转为 32 位整数表示。</p><hr><p><code>inet_addr</code> 函数可用于转换，该函数在转换的同时会进行网络字节序的转换。</p><p><code>inet_ntoa</code> 函数则相反，将 <code>in_addr</code> 结构体转为字符串。</p><p><strong>注意：</strong><code>inet_ntoa</code> 函数返回的是一个指向静态缓冲区的指针，最好将返回值拷贝到其它地方，以免被覆盖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in_addr_t</span> <span style=color:#a6e22e>inet_addr</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>inet_ntoa</span>(<span style=color:#66d9ef>struct</span> in_addr in);
</span></span></code></pre></div><p>也可以使用 <code>inet_aton</code> 函数，该函数将结果直接保存到传入的 <code>inp</code> 结构体中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>inet_aton</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cp, <span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>inp);
</span></span></code></pre></div><h4 id=in6_addr>in6_addr</h4><p><code>sockaddr_in5</code> 结构体中的 <code>in6_addr</code> 结构体包含一个 <code>unsigned char</code> 类型的成员 <code>s6_addr</code>，用于存储 128 位的 IPv6 地址。</p><p><code>inet_pton</code> 函数中的 <code>af</code> 参数必须为 <code>AF_INET</code> 和 <code>AF_INET6</code>，分别处理 IPv4 和 IPv6 协议。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>inet_pton</span>(<span style=color:#66d9ef>int</span> af, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>restrict</span> src, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>restrict</span> dst);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>inet_ntop</span>(<span style=color:#66d9ef>int</span> af, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>restrict</span> src,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>char</span> dst[<span style=color:#66d9ef>restrict</span> .size], <span style=color:#66d9ef>socklen_t</span> size);
</span></span></code></pre></div><h3 id=网络地址初始化>网络地址初始化</h3><h4 id=ipv4>IPv4</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;211.123.211.168&#34;</span>; <span style=color:#75715e>// IP 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>port <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;7890&#34;</span>;               <span style=color:#75715e>// 端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in addr;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;                 <span style=color:#75715e>// IPv4;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(address); <span style=color:#75715e>// 设置 IP 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#a6e22e>atoi</span>(port));         <span style=color:#75715e>// 以网络字节序设置端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=ipv6>IPv6</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;2001:0db8:85a3:0000:0000:8a2e:0370:7334&#34;</span>; <span style=color:#75715e>// IPv6 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>port <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;7890&#34;</span>;                     <span style=color:#75715e>// 端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in6 addr;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin6_family <span style=color:#f92672>=</span> AF_INET6;                   <span style=color:#75715e>// IPv6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>inet_pton</span>(AF_INET6, address, <span style=color:#f92672>&amp;</span>addr.sin6_addr); <span style=color:#75715e>// 设置 IP 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    addr.sin6_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#a6e22e>atoi</span>(port));            <span style=color:#75715e>// 以网络字节序设置端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=思考>思考</h3><p>为什么 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别表示 IPv4 和 IPv6 协议，还要额外使用 <code>sa_family_t</code> 指定协议版本呢？</p><blockquote><p>因为 <code>connect</code>、<code>bind</code>、和 <code>accept</code> 函数第二个参数都接收 <code>sockaddr</code> 结构体。因此，需要使用 <code>sa_family</code> 用于区分不同版本的协议。通过使用通用的 <code>sockaddr</code> 结构体，该函数不仅可以处理 IPv4 和 IPv6 协议，还可处理其它协议。这样，就不需要为每种协议都提供对应的函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sa_family_t</span>     sa_family;      <span style=color:#75715e>/* Address family */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span>            sa_data[];      <span style=color:#75715e>/* Socket address */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></blockquote><h2 id=套接字socket>套接字（socket）</h2><p><strong>网络编程</strong>即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的<strong>套接字（socket）</strong>。</p><h3 id=基本函数>基本函数</h3><h4 id=socket>socket</h4><p>为了使用套接字，可以使用 <code>socket</code> 函数，创建用于通信的端点（endpoint）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>socket</span>(<span style=color:#66d9ef>int</span> domain, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol);
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/socket.2.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/socket.2.html</a></p></blockquote><h4 id=bind>bind</h4><p>当使用 <code>socket</code> 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。<code>bind</code> 函数将 <code>addr</code> 指定的地址分配给文件描述符 <code>sockfd</code> 引用的套接字。</p><p>服务器可以不先调用 <code>bind()</code> 而直接调用 <code>listen()</code>，此时会为该 <code>socket</code> 分配一个 <strong><code>INADDR_ANY</code> IP 地址</strong>（0.0.0.0）和<strong>临时端口</strong>（可通过 <code>getsockname()</code> 获取 <code>socket</code> 的地址）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>addr,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>socklen_t</span> addrlen);
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/bind.2.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/bind.2.html</a></p></blockquote><h4 id=listen>listen</h4><p><code>listen</code> 函数将文件描述符引用的 <code>socket</code> 标记为被动，该 <code>socket</code> 会被用来接受来自其它主动 <code>socket</code> 的连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>listen</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>int</span> backlog);
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/listen.2.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/listen.2.html</a></p></blockquote><h4 id=accept>accept</h4><p>执行 <code>accept</code> 函数会创建一个新的 <code>socket</code>，此 <code>socket</code> 会与执行 <code>connect</code> 函数的 <code>socket</code> 进行连接。此函数调用返回值是已连接的 <code>socket</code> 的文件描述符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>accept</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>_Nullable <span style=color:#66d9ef>restrict</span> addr,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>socklen_t</span> <span style=color:#f92672>*</span>_Nullable <span style=color:#66d9ef>restrict</span> addrlen);
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/accept.2.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/accept.2.html</a></p></blockquote><h4 id=connect>connect</h4><p><code>connect</code> 函数将文件描述符 <code>sockfd</code> 引用的套接字连接到由 <code>addr</code> 指定的地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>connect</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>addr,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>socklen_t</span> addrlen);
</span></span></code></pre></div><blockquote><p><a href=https://man7.org/linux/man-pages/man2/connect.2.html target=_blank rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/connect.2.html</a></p></blockquote><h3 id=套接字协议>套接字协议</h3><p><code>socket</code> 函数（<code>int socket(int domain, int type, int protocol)</code>）有三个参数用于选择传输协议和方式。</p><h4 id=协议族domain>协议族（domain）</h4><p>所有的协议族可以点击 <a href=https://man7.org/linux/man-pages/man7/address_families.7.html target=_blank rel="noopener noreferrer">address_families</a> 查看，主要的协议族分类如下：</p><table><thead><tr><th>协议族</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>使用 IPv4 地址</td></tr><tr><td>AF_INET6</td><td>使用 IPv6 地址</td></tr><tr><td>AF_UNIX</td><td>本地通信，用于同一台机器上的进程间通信</td></tr><tr><td>AF_PACKET</td><td>原始数据包捕获和注入，需要特殊权限</td></tr><tr><td>AF_NETLINK</td><td>用于 Linux 内核与用户空间进程之间的通信</td></tr></tbody></table><hr><p><code>AF_常量</code> 和 <code>PF_常量</code> 的区别？</p><blockquote><p>AF 表示地址族（address family），PF 表示协议族（protocol family）。在一开始的时候，设计人员相信单个协议族可以支持多个地址族。但在实践中，没有哪一个协议族能够支持多个已经被定义的地址族，并且所有既有实现都将 <code>PF_常量</code> 定义成对应的 <code>AF_常量</code> 的同义词。</p></blockquote><h4 id=数据传输方式type>数据传输方式（type）</h4><p>数据传输类型主要有以下两种：</p><ul><li><strong>面向连接</strong>的套接字（SOCK_STREAM）：提供有序的、可靠的、双向的、基于连接的字节流。可以支持带外（<a href=https://en.wikipedia.org/wiki/Out-of-band_data target=_blank rel="noopener noreferrer">out-of-band</a>）数据传输机制。</li><li><strong>面向消息</strong>的套接字（SOCK_DGRAM）：支持数据报（无连接、最大长度固定的不可靠消息）。</li></ul><h4 id=协议protocol>协议（protocol）</h4><p>在给定的协议族中，通常只有一个协议存在以支持特定的套接字类型，在这种情况下，可以将 <code>protocol</code> 指定为 0。</p><p>在大部分情况下，第三个参数传递 0 即可。然而，协议族下可能存在许多协议，在这种情况下，必须使用 <code>protocol</code> 指定一个特定的协议。</p><h2 id=io-多路复用>I/O 多路复用</h2><p>I/O 复用可以使程序同时监听多个文件描述符。</p><h3 id=select>select</h3><p><code>select</code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。</p><p><code>select</code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 <code>errno</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> nfds, fd_set<span style=color:#f92672>*</span> readfds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> writefds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> exceptfds,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> timeval <span style=color:#f92672>*</span> timeout);
</span></span></code></pre></div><h4 id=函数参数>函数参数</h4><p><code>nfds</code>：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。</p><hr><p><code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 <code>fd_set</code> 参数设为 <code>NULL</code>。</p><p><code>fd_set</code> 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 <code>FD_SETSIZE</code> 指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* fd_set for select and pselect.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* XPG4.2 requires this member name.  Otherwise avoid the name
</span></span></span><span style=display:flex><span><span style=color:#75715e>       from the global namespace.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_XOPEN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask __fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;__fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  } fd_set;
</span></span></code></pre></div><p>为方便对此结构体进行操作，提供了以下几个宏函数对其进行操作，宏函数如下：</p><blockquote><p>为方便展示，对宏函数中的所有参数加上了类型</p></blockquote><ul><li><code>FD_SET(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 添加到 <code>fdset</code> 指向的集合中。</li><li><code>FD_CLR(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 从 <code>fdset</code> 指向的集合中移除。</li><li><code>FD_ISSET(fd, fdsetp)</code>：如果文件描述符 <code>fd</code> 是 <code>fdset</code> 指向的集合中的成员，则返回 <code>true</code>。</li><li><code>FD_ZERO(fdsetp)</code>：将 <code>fdset</code> 指向的集合初始化为空。</li></ul><hr><p><code>timeval</code>：用来设置 <code>select</code> 函数的超时时间，采用指针作为参数是因为内核将修改以告诉应用程序 select 等待了多久。</p><p>如果 <code>timeval</code> 结构体中的 <code>tv_sec</code> 和 <code>tv_usec</code> 成员都传递 0，则 <code>select</code> 函数立即返回。如果传递 <code>NULL</code>，则一直阻塞，直到某个文件描述符就绪。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* A time value that is accurate to the nearest
</span></span></span><span style=display:flex><span><span style=color:#75715e>   microsecond but also has a range of years.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> timeval
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_TIME_BITS64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time64_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds64_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h4 id=就绪条件>就绪条件</h4><p>在网络编程中，下边情况下 <code>socket</code> 可读：</p><p>在网络编程中，下边情况下 <code>socket</code> 可写：</p><p><code>select</code> 函数能处理的异常情况只有一种：<code>socket</code> 上接收到带外数据。</p><h4 id=循环中使用>循环中使用</h4><p>由于这些结构体会在调用中被修改，如果要在循环中重复调用 <code>select</code> 函数，我们必须保证每次都要重新初始化它们。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C></code></pre></div><h3 id=poll>poll</h3><p><code>poll</code> 函数和 <code>select</code> 函数调用返回值一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;poll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>struct</span> pollfd <span style=color:#f92672>*</span>fds, <span style=color:#66d9ef>nfds_t</span> nfds, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><h4 id=函数参数-1>函数参数</h4><p><code>fds</code>：需要 <code>poll</code> 函数检查的文件描述符，该参数为 <code>pollfd</code> 结构体数组。</p><p><code>pollfd</code> 结构体中 <code>fd</code> 指定文件描述符；<code>events</code> 告诉 <code>poll</code> 函数需要监听哪些事件；<code>revents</code> 由内核对其进行修改，以通知应用程序 <code>fd</code> 上实际发生了哪些事件。</p><table><thead><tr><th>位掩码</th><th>events</th><th>返回到revents</th><th>描述</th></tr></thead><tbody><tr><td>POLLIN</td><td>●</td><td>●</td><td>可读取非高优先级的数据</td></tr><tr><td>POLLRDNORM</td><td>●</td><td>●</td><td>等同于POLLIN</td></tr><tr><td>POLLRDBAND</td><td>●</td><td>●</td><td>可读取优先级数据（Linux 中不使用）</td></tr><tr><td>POLLPRI</td><td>●</td><td>●</td><td>可读取高优先级数据</td></tr><tr><td>POLLRDHUP</td><td>●</td><td>●</td><td>对端套接字关闭</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLOUT</td><td>●</td><td>●</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>●</td><td>●</td><td>等同于POLLOUT</td></tr><tr><td>POLLWRBAND</td><td>●</td><td>●</td><td>优先级数据可写入</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLERR</td><td></td><td>●</td><td>有错误发生</td></tr><tr><td>POLLHUP</td><td></td><td>●</td><td>出现挂断</td></tr><tr><td>POLLNVAL</td><td></td><td>●</td><td>文件描述符未打开</td></tr><tr><td>POLLMSG</td><td></td><td></td><td>Linux 中不使用</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> pollfd {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p><code>nfds</code>：用于指定数组 <code>fds</code> 中元素的个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Type used for the number of file descriptors.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>nfds_t</span>;
</span></span></code></pre></div><hr><p><code>timeout</code>：指定 <code>poll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>poll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>poll</code> 调用将立即返回。</li></ul><h3 id=epoll>epoll</h3><p><code>epoll</code> 是 Linux 特有的 I/O 复用函数。<code>epoll</code> 需要使用额外的文件描述符，标识内核中的这个事件表，需要使用 <code>epoll_create</code> 函数创建，返回文件描述符。</p><p><code>size</code> 是想要通过 <code>epoll</code> 来检查的文件描述符个数。该参数并不是一个上限，而是告诉内核应该如何为内部数据结构划分初始大小（从 Linux 2.6.8 版以来，<code>size</code> 参数被忽略不用，因为内核实现做了修改意味着该参数提供的信息已经不再需要了）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span> (<span style=color:#66d9ef>int</span> size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create1</span> (<span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><h4 id=epoll_ctl>epoll_ctl</h4><p><code>epoll_ctl</code> 函数能够修改由文件描述符 <code>epfd</code> 所代表的兴趣列表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd,
</span></span><span style=display:flex><span>		      <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event);
</span></span></code></pre></div><hr><p><code>epfd</code> 是调用 <code>epoll_create</code> 函数的返回值。</p><hr><p><code>op</code> 用于操作操作类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Valid opcodes ( &#34;op&#34; parameter ) to issue to epoll_ctl().  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_ADD 1	</span><span style=color:#75715e>/* Add a file descriptor to the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_DEL 2	</span><span style=color:#75715e>/* Remove a file descriptor from the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_MOD 3	</span><span style=color:#75715e>/* Change file descriptor epoll_event structure.  */</span><span style=color:#75715e>
</span></span></span></code></pre></div><hr><p><code>events</code> 是一个位掩码，指定了待检查描述符 <code>fd</code> 上感兴趣的事件集合。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> epoll_event
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> events;	 <span style=color:#75715e>/* Epoll events */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>epoll_data_t</span> data; <span style=color:#75715e>/* User data variable */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>data</code> 当描述符 <code>fd</code> 就绪时，传递给调用者的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> epoll_data
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> u32;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> u64;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>epoll_data_t</span>;
</span></span></code></pre></div><h4 id=epoll_wait>epoll_wait</h4><p>返回 <code>epoll</code> 实例中处于就绪态的文件描述符信息。单个 <code>epoll_wait</code> 函数调用能返回多个就绪态文件描述符的信息。</p><p>调用成功后，<code>epoll_wait</code> 函数返回数组 <code>events</code> 元素个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>events,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><hr><p><code>events</code> 所指向的结构体数组中返回的是有关就绪态文件描述符的信息。</p><p>数组 <code>events</code> 的空间由调用者负责申请，所包含的元素个数由参数 <code>maxevents</code> 指定。</p><hr><p><code>timeout</code>：指定 <code>epoll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>epoll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>epoll</code> 执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件。</li><li>当 <code>timeout</code> 大于 0 时，<code>epoll</code> 阻塞至多 <code>timeout</code> 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止。</li></ul><h4 id=水平触发和边缘触发>水平触发和边缘触发</h4><p><code>epoll</code> 默认工作模式为<strong>水平触发</strong>，当往 <code>epoll</code> 内核事件表中注册一个文件描述符上的 <code>EPOLLET</code> 事件时，将以<strong>边缘触发</strong>模式工作。</p><ul><li><p>LT 模式（水平）：缓冲区剩余未读尽的数据<strong>会</strong>导致 <code>epoll_wait</code> 返回。直到新的事件满足才会触发。支持阻塞和非阻塞。</p></li><li><p>ET 模式（边缘）：缓冲区剩余未读尽的数据<strong>不会</strong>导致 <code>epoll_wait</code> 返回。必须设置为非阻塞。</p></li></ul><h2 id=echo-服务器>echo 服务器</h2><h3 id=辅助函数>辅助函数</h3><p><code>panic</code> 函数用于错误处理，当发生错误时，调用 <code>exit</code> 函数直接退出程序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>panic</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) {
</span></span><span style=display:flex><span>  va_list args;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_start</span>(args, format);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vfprintf</span>(stderr, format, args);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_end</span>(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>readn</code> 和 <code>writen</code> 函数分别用于从 <code>fd</code> 处读和写 <code>n</code> 个字节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> <span style=color:#a6e22e>readn</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>size_t</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ssize_t</span> nread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (nleft <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((nread <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd, buf, nleft)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (nleft <span style=color:#f92672>==</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// error, return -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// error, return amount read so far
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (nleft <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((nread <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd, buf, nleft)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (nleft <span style=color:#f92672>==</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// error, return -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    nleft <span style=color:#f92672>-=</span> nread;
</span></span><span style=display:flex><span>    buf <span style=color:#f92672>+=</span> nread;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> n <span style=color:#f92672>-</span> nleft;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> <span style=color:#a6e22e>writen</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>size_t</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> nleft <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ssize_t</span> nwritten;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (nleft <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((nwritten <span style=color:#f92672>=</span> <span style=color:#a6e22e>write</span>(fd, buf, nleft)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (nleft <span style=color:#f92672>==</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nwritten <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    nleft <span style=color:#f92672>-=</span> nwritten;
</span></span><span style=display:flex><span>    buf <span style=color:#f92672>+=</span> nwritten;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> n <span style=color:#f92672>-</span> nleft;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>read_line</code> 函数用于从用户处读取一行输入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>read_line</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>line <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> buf_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ssize_t</span> n_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>getline</span>(<span style=color:#f92672>&amp;</span>line, <span style=color:#f92672>&amp;</span>buf_size, stdin);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (n_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;error: reading input</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (line[n_bytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>    line[n_bytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> line;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>set_nonblocking</code> 函数用于将 <code>fd</code> 设为非阻塞模式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>set_nonblocking</span>(<span style=color:#66d9ef>int</span> fd) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> flags <span style=color:#f92672>=</span> <span style=color:#a6e22e>fcntl</span>(fd, F_GETFL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fcntl</span>(fd, F_SETFL, flags <span style=color:#f92672>|</span> O_NONBLOCK) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>create_sockaddr_in</code> 函数用于创建 <code>struct sockaddr_in</code> 结构体。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span><span style=color:#a6e22e>create_sockaddr_in</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in));
</span></span><span style=display:flex><span>  addr<span style=color:#f92672>-&gt;</span>sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>  addr<span style=color:#f92672>-&gt;</span>sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(address);
</span></span><span style=display:flex><span>  addr<span style=color:#f92672>-&gt;</span>sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(port);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> addr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于 <code>socket</code>、<code>bind</code>、<code>listen</code>、<code>accept</code> 和 <code>connect</code> 函数，大部分使用都是一样的，对其进行封装。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Socket</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;socket() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Bind</span>(<span style=color:#66d9ef>int</span> socket_fd, <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>addr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bind</span>(socket_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(addr), <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;bind() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Listen</span>(<span style=color:#66d9ef>int</span> socket_fd) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>listen</span>(socket_fd, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;listen() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Accept</span>(<span style=color:#66d9ef>int</span> socket_fd, <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>addr, <span style=color:#66d9ef>socklen_t</span> <span style=color:#f92672>*</span>addr_len) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(socket_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)addr, addr_len);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;accept() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>set_nonblocking</span>(fd);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;set_nonblocking error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Connect</span>(<span style=color:#66d9ef>int</span> socket_fd, <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>addr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>connect</span>(socket_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(addr), <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;connect() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=客户端>客户端</h3><p>客户端读取一行用户的输入，将数据传给服务器，服务器将所有的字母大写后再传给客户端。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_client</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>remote_address, <span style=color:#66d9ef>int</span> remote_port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>Socket</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>server_addr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>create_sockaddr_in</span>(remote_address, remote_port);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Connect</span>(client_fd, server_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>input <span style=color:#f92672>=</span> <span style=color:#a6e22e>read_line</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> input_len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[input_len <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (input_len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> out;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> sent_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>send</span>(client_fd, input, input_len, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sent_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;send() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> recv_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(client_fd, buf, input_len, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (recv_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;recv() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>  out:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(input);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=为什么多路复用需要搭配非阻塞>为什么多路复用需要搭配非阻塞</h3><pre tabindex=0><code>On Linux, select() may report a socket file descriptor as &#34;ready
for reading&#34;, while nevertheless a subsequent read blocks.  This
could for example happen when data has arrived but upon
examination has the wrong checksum and is discarded.  There may
be other circumstances in which a file descriptor is spuriously
reported as ready.  Thus it may be safer to use O_NONBLOCK on
sockets that should not block.
</code></pre><p>参考链接：<a href="https://man7.org/linux/man-pages/man2/select.2.html#:~:text=On%20Linux%2C%20select%28%29%20may,sockets%20that%20should%20not%20block." target=_blank rel="noopener noreferrer">select</a></p><h3 id=普通版本>普通版本</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ctype.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdarg.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> used_for_cleanup_fd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>panic</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) {
</span></span><span style=display:flex><span>  va_list args;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_start</span>(args, format);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vfprintf</span>(stderr, format, args);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_end</span>(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (used_for_cleanup_fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(used_for_cleanup_fd);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_client</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>remote_address, <span style=color:#66d9ef>int</span> remote_port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>512</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;socket() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atexit</span>(cleanup);
</span></span><span style=display:flex><span>  used_for_cleanup_fd <span style=color:#f92672>=</span> client_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in server_addr;
</span></span><span style=display:flex><span>  server_addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>  server_addr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(remote_address);
</span></span><span style=display:flex><span>  server_addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(remote_port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>connect</span>(client_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>server_addr),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>sizeof</span>(server_addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;connect() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fgets</span>(buf, <span style=color:#66d9ef>sizeof</span>(buf), stdin);
</span></span><span style=display:flex><span>    buf[<span style=color:#a6e22e>strcspn</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> buf_len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf_len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf_len <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>sizeof</span>(buf) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;input too long</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> sent_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>send</span>(client_fd, buf, buf_len, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sent_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;send() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> recv_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (recv_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;recv() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_server</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>512</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in server_addr;
</span></span><span style=display:flex><span>  server_addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>  server_addr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(address);
</span></span><span style=display:flex><span>  server_addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> server_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (server_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;socket() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atexit</span>(cleanup);
</span></span><span style=display:flex><span>  used_for_cleanup_fd <span style=color:#f92672>=</span> server_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bind</span>(server_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>server_addr), <span style=color:#66d9ef>sizeof</span>(server_addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;bind() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>listen</span>(server_fd, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;listen() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in client_addr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>socklen_t</span> client_addr_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(client_addr);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>accept</span>(server_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>client_addr), <span style=color:#f92672>&amp;</span>client_addr_len);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;accept() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ssize_t</span> read_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (read_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;recv() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (read_bytes <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(client_fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>ssize_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> read_bytes; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        buf[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span>)<span style=color:#a6e22e>toupper</span>((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>)buf[i]);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>ssize_t</span> sent_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>send</span>(client_fd, buf, read_bytes, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (sent_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;send() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;usage: &lt;mode&gt; &lt;IP&gt; &lt;port&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mode <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncmp</span>(mode, <span style=color:#e6db74>&#34;client&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run_client</span>(address, port);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncmp</span>(mode, <span style=color:#e6db74>&#34;server&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run_server</span>(address, port);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=select-版本>select 版本</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ctype.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdarg.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX(a, b) a &lt; b ? b : a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> used_for_cleanup_fd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>panic</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) {
</span></span><span style=display:flex><span>  va_list args;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_start</span>(args, format);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vfprintf</span>(stderr, format, args);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>va_end</span>(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (used_for_cleanup_fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(used_for_cleanup_fd);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_client</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>remote_address, <span style=color:#66d9ef>int</span> remote_port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>512</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;socket() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atexit</span>(cleanup);
</span></span><span style=display:flex><span>  used_for_cleanup_fd <span style=color:#f92672>=</span> client_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in server_addr;
</span></span><span style=display:flex><span>  server_addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>  server_addr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(remote_address);
</span></span><span style=display:flex><span>  server_addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(remote_port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>connect</span>(client_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>server_addr),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>sizeof</span>(server_addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;connect() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fgets</span>(buf, <span style=color:#66d9ef>sizeof</span>(buf), stdin);
</span></span><span style=display:flex><span>    buf[<span style=color:#a6e22e>strcspn</span>(buf, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> buf_len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf_len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buf_len <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>sizeof</span>(buf) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;input too long</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> sent_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>send</span>(client_fd, buf, buf_len, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sent_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;send() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ssize_t</span> recv_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(client_fd, buf, <span style=color:#66d9ef>sizeof</span>(buf), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (recv_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;recv() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run_server</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>512</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in server_addr;
</span></span><span style=display:flex><span>  server_addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>  server_addr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(address);
</span></span><span style=display:flex><span>  server_addr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> server_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (server_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;socket() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>atexit</span>(cleanup);
</span></span><span style=display:flex><span>  used_for_cleanup_fd <span style=color:#f92672>=</span> server_fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>bind</span>(server_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>server_addr), <span style=color:#66d9ef>sizeof</span>(server_addr));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;bind() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>listen</span>(server_fd, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;listen() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> sockaddr_in client_addr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>socklen_t</span> client_addr_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(client_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fd_set fds;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>FD_ZERO</span>(<span style=color:#f92672>&amp;</span>fds);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>FD_SET</span>(server_fd, <span style=color:#f92672>&amp;</span>fds);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> max_fd <span style=color:#f92672>=</span> server_fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    fd_set rfds <span style=color:#f92672>=</span> fds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> retval <span style=color:#f92672>=</span> <span style=color:#a6e22e>select</span>(max_fd <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>rfds, NULL, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;select() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(server_fd, <span style=color:#f92672>&amp;</span>rfds)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// new connection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> client_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(server_fd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>client_addr),
</span></span><span style=display:flex><span>                             <span style=color:#f92672>&amp;</span>client_addr_len);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (client_fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;accept() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>FD_SET</span>(client_fd, <span style=color:#f92672>&amp;</span>fds);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      max_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAX</span>(max_fd, client_fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> server_fd <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; fd <span style=color:#f92672>&lt;=</span> max_fd; fd<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(fd, <span style=color:#f92672>&amp;</span>rfds)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ssize_t</span> read_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(fd, buf, <span style=color:#66d9ef>sizeof</span>(buf), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (read_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;recv() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (read_bytes <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>FD_CLR</span>(fd, <span style=color:#f92672>&amp;</span>fds);
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>ssize_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> read_bytes; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>          buf[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span>)<span style=color:#a6e22e>toupper</span>((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>)buf[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ssize_t</span> sent_bytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>send</span>(fd, buf, read_bytes, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sent_bytes <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;send() error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic</span>(<span style=color:#e6db74>&#34;usage: &lt;mode&gt; &lt;IP&gt; &lt;port&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mode <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncmp</span>(mode, <span style=color:#e6db74>&#34;client&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run_client</span>(address, port);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strncmp</span>(mode, <span style=color:#e6db74>&#34;server&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>run_server</span>(address, port);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2025, Leon Li.</div></footer></html>