<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Java 模块化</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css><style>body{font-family:source han serif cn vf}</style></head><body class="bg:fade-84@dark font:fade-16@dark"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;}
_:where(th){font:fade-78;_font:14;_text:left}
_:where(th,p_code,li_code,a,mark){font:semibold}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-30;_my:1em}"><h1 id=java-模块化翻译>Java 模块化（翻译）</h1><blockquote><p>本文翻译自：https://www.oracle.com/corporate/features/understanding-java-9-modules.html</p></blockquote><p>在本文中，我将介绍 Java 9 平台模块系统（JPMS），这是自 Java 诞生以来最重要的新软件工程技术。模块化（即 <a href=http://openjdk.java.net/projects/jigsaw/ target=_blank rel="noopener noreferrer">Jigsaw 项目</a> 的成果）有助于各级开发人员在构建、维护和发展软件系统，特别是大型系统时，提高生产力。</p><h2 id=什么是模块化>什么是模块化</h2><p>模块化在包的基础上增加了一个更高层次的聚合。关键的新语言元素是模块（一个唯一命名且可重用的相关包的组合，以及资源（如图像和 XML 文件））和一个模块描述符，用于指定以下内容：</p><ul><li>模块的名称</li><li>模块的依赖关系（即该模块所依赖的其它模块）</li><li>它显式提供给其它模块使用的包（默认情况下，其它模块的不可使用非显示提供的包）</li><li>它提供的服务</li><li>它使用的服务</li><li>允许哪些模块进行反射访问</li></ul><h2 id=历史>历史</h2><p>Java SE 自 1995 年问世以来，已有大约 1000 万开发者使用它来构建从资源受限设备（如物联网（IoT）和其它嵌入式设备）的小型应用程序，到大规模的关键业务和关键任务系统。尽管存在大量的遗留代码，但迄今为止，Java 主要是一个一体化的通用解决方案。多年来，人们进行了各种模块化 Java 的努力，不仅没有一个被广泛使用，而且也没有一个能够用于模块化 Java 平台的实现。</p><p>Java SE 平台的模块化实现一直充满挑战，这一努力花费了许多年时间。<a href="https://jcp.org/en/jsr/detail?id=277" target=_blank rel="noopener noreferrer">JSR 277: Java Module System</a> 最初于 2005 年针对 Java 7 提出。随后，该 JSR 被 <a href="https://jcp.org/en/jsr/detail?id=376" target=_blank rel="noopener noreferrer">JSR 376: Java Platform Module System</a> 取代，并计划用于 Java 8。最终，Java SE 平台在 Java 9 中实现了模块化，但这一过程导致 Java 9 的发布被推迟至 2017 年 9 月。</p><h2 id=目标>目标</h2><blockquote><p>每个模块都必须明确声明其依赖关系。</p></blockquote><p>根据 JSR 376，Java SE 平台的模块化的主要目标包括：</p><ul><li><strong>可靠的配置</strong>：模块化提供了一种机制，能够在编译时和运行时明确声明模块之间的依赖关系。系统可以通过这些依赖关系遍历，确定支持应用程序所需模块的最小子集。</li><li><strong>强封装性</strong>：模块中的包只有在模块显式导出时，才能被其它模块访问。即便如此，另一个模块也必须明确声明需要该模块的功能才能使用这些包。这提高了平台的安全性，因为潜在攻击者可以访问的类更少。您可能会发现，考虑模块化有助于设计出更清晰、更符合逻辑的系统。</li><li><strong>可扩展的 Java 平台</strong>：此前，Java 平台是一个由大量包组成的单一整体，导致开发、维护和演进变得困难，且无法轻松子集化。现在，平台被模块化为 95 个模块（随着 Java 的发展，这个数字可能会变化）。您可以为应用程序或目标设备创建仅包含所需模块的自定义运行时。例如，如果设备不支持 GUI，您可以创建一个不包含 GUI 模块的运行时，从而显著减小运行时的体积。</li><li><strong>更高的平台完整性</strong>：在 Java 9 之前，应用程序可以使用平台中许多本不应被使用的类。通过强封装性，这些内部 API 被真正封装起来，对使用平台的应用程序隐藏。如果您的代码依赖于这些内部 API，迁移到模块化的 Java 9 可能会遇到问题。</li><li><strong>性能提升</strong>：JVM 使用各种优化技术来提高应用程序性能。JSR 376 指出，如果提前知道所需的类型仅位于特定模块中，这些优化技术会更加有效。</li></ul><h2 id=列出-jdk-的模块>列出 JDK 的模块</h2><p>Java 9 的一个重要方面是将 JDK 划分为模块以支持各种配置。（请参考 <a href=https://openjdk.org/jeps/200 target=_blank rel="noopener noreferrer">JEP 200: The Modular JDK</a>。所有与 Java 模块化相关的 JEP 和 JSR 如 <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html#:~:text=Table%201.%20Java%20Modularity%20JEPs%20and%20JSRs" target=_blank rel="noopener noreferrer">Java Modularity JEPs and JSRs</a> 所示。）使用 JDK 的 bin 文件夹中的 <code>java</code> 命令并添加 <code>--list-modules</code> 选项，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>java --list-modules
</span></span></code></pre></div><p>可以列出 JDK 的模块集合，其中包括实现 Java 语言 SE 规范的标准模块（名称以 <code>java</code> 开头）、JavaFX 模块（名称以 <code>javafx</code> 开头）、JDK 特定模块（名称以 <code>jdk</code> 开头）以及 Oracle 特定模块（名称以 <code>oracle</code> 开头）。每个模块名称后面都跟有一个版本字符串（<code>@9</code>）表示该模块属于 Java 9。</p><h2 id=模块声明>模块声明</h2><blockquote><p>模块系统的主要动机是<strong>强隔离性</strong>。</p></blockquote><p>正如我们提到的，模块必须提供一个模块描述符——即元数据，用于指定模块的依赖关系、模块向其它模块提供的包等信息。模块描述符是模块声明的编译版本，模块声明定义在一个名为 <code>module-info.java</code> 的文件中。每个模块声明以关键字 <code>module</code> 开头，后跟一个唯一的模块名称和用大括号括起来的模块体，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>module modulename { 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>模块声明的正文可以为空，也可以包含各种模块指令，包括 <code>require, exports, provides…with, uses</code> 和 <code>opens</code>（我们将逐一讨论这些指令）。正如您稍后将看到的，编译模块声明会创建模块描述符，该描述符存储在模块根文件夹中名为 <code>module-info.class</code> 的文件中。在这里，我们简要介绍每个模块指令。之后，我们将展示实际的模块声明。</p><p>关键字 <code>exports, module, open, opens, provides, requires, uses, with</code>，以及稍后介绍的 <code>to</code> 和 <code>transitive</code>，都是受限关键字。它们仅在模块声明中是关键字，在代码的其它任何地方都可以用作标识符。</p><h3 id=requires>requires</h3><p><code>requires</code> 模块指令指定此模块依赖于另一个模块——这种关系称为模块依赖关系。每个模块必须明确声明其依赖关系。当模块 A 需要模块 B 时，模块 A 被称为读取模块 B，而模块 B 被模块 A 读取。要指定对另一个模块的依赖关系，请使用 <code>requires</code>，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>requires modulename;
</span></span></code></pre></div><p>还存在一种 <code>requires static</code> 指令，用于表示某个模块在编译时是必需的，但在运行时是可选的。这被称为可选依赖关系，本简介中不会讨论这一点。</p><p><code>requires transitive</code> 指令表示隐式可读性。要指定对另一个模块的依赖关系，并确保读取您模块的其它模块也读取该依赖关系（称为隐式可读性），请使用 <code>requires transitive</code>，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>requires transitive modulename;
</span></span></code></pre></div><p>考虑以下来自 <code>java.desktop</code> 模块声明的指令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>requires transitive java.<span style=color:#a6e22e>xml</span>;
</span></span></code></pre></div><p>在这种情况下，任何读取 <code>java.desktop</code> 的模块也会隐式读取 <code>java.xml</code>。例如，如果 <code>java.desktop</code> 模块中的某个方法返回了 <code>java.xml</code> 模块中的类型，那么读取 <code>java.desktop</code> 的模块中的代码就会依赖于 <code>java.xml</code>。如果在 <code>java.desktop</code> 的模块声明中没有 <code>requires transitive</code> 指令，这些依赖模块将无法编译，除非它们显式读取 <code>java.xml</code>。</p><p>根据 JSR 379，Java SE 的标准模块必须在所有类似情况下授予隐式可读性。此外，尽管 Java SE 标准模块可能依赖于非标准模块，但它不得向它们授予隐式可读性。这确保了仅依赖于 Java SE 标准模块的代码在 Java SE 实现之间是可移植的。</p><h3 id=exports-和-exportsto>exports 和 exports…to</h3><p><code>exports</code> 模块指令指定模块的一个包，其它模块可访问该包的所有公共类型（及其嵌套的公共和受保护类型）的代码。<code>exports…to</code> 指令允许您在逗号分隔的列表中精确指定导出哪些模块的代码——这被称为限定导出。</p><h3 id=uses>uses</h3><p><code>uses</code> 模块指令指定此模块使用的服务——使该模块成为服务使用者。服务是实现 <code>uses</code> 指令中指定的接口或抽象类的对象。</p><h3 id=provideswith>provides…with</h3><p><code>provides…with</code> 模块指令指定模块提供服务的实现——使该模块成为服务提供者。指令的 <code>provides</code> 部分指定模块 <code>uses</code> 指令中列出的接口或抽象类，而 <code>with</code> 部分指定实现该接口或扩展该抽象类的服务提供者类的名称。</p><h3 id=openopens-和-opensto>open、opens 和 opens…to</h3><p>在 Java 9 之前，反射可以用来了解包中的所有类型以及类型的所有成员——甚至是私有成员——无论您是否希望允许这种能力。因此，没有任何东西是真正封装的。</p><p>模块系统的一个关键动机是强封装。默认情况下，模块中的类型对其它模块不可访问，除非它是公共类型并且您导出了其包。在 Java 9 中，这也适用于反射。</p><p><strong>允许仅在运行时访问包</strong></p><p><code>opens</code> 模块指令的形式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>opens package;
</span></span></code></pre></div><p>表示特定包的公共类型（及其嵌套的公共和受保护类型）仅在运行时对其它模块中的代码可访问。此外，指定包中的所有类型（以及所有类型的成员）都可以通过反射访问。</p><p><strong>允许特定模块仅在运行时访问包</strong></p><p><code>opens…to</code> 模块指令的形式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>opens <span style=color:#f92672>package</span> to comma<span style=color:#f92672>-</span>separated<span style=color:#f92672>-</span>list<span style=color:#f92672>-</span>of<span style=color:#f92672>-</span>modules;
</span></span></code></pre></div><p>表示特定包的公共类型（及其嵌套的公共和受保护类型）仅在运行时对列出的模块中的代码可访问。指定包中的所有类型（以及所有类型的成员）都可以通过反射对指定模块中的代码访问。</p><p><strong>允许仅在运行时访问模块中的所有包</strong><br>如果给定模块中的所有包应在运行时并通过反射对所有其它模块可访问，您可以打开整个模块，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>open module modulename {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 模块指令</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=默认反射设置>默认反射设置</h2><p>默认情况下，具有运行时反射访问权限的模块可以访问包中的公共类型（及其嵌套的公共和受保护类型）。然而，与早期 Java 版本一样，其它模块中的代码可以访问暴露包中的所有类型以及这些类型中的所有成员，包括通过 <code>setAccessible</code> 访问私有成员。</p><p>有关 <code>setAccessible</code> 和反射的更多信息，请参阅 <a href=https://docs.oracle.com/javase/tutorial/reflect/ target=_blank rel="noopener noreferrer">Oracle 的官方文档</a>。</p></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2025, Leon Li.</div></footer></html>