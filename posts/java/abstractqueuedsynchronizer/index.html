<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Java AQS（翻译）</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css><style>body{font-family:source han serif cn vf}</style></head><body class="bg:fade-84@dark font:fade-16@dark"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;}
_:where(th){font:fade-78;_font:14;_text:left}
_:where(th,p_code,li_code,a,mark){font:semibold}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-30;_my:1em}"><h1 id=java-aqs翻译>Java AQS（翻译）</h1><blockquote><p>本文是 Doug Lea 的 <em>The java.util.concurrent Synchronizer Framework</em> 一文的翻译，该论文描述了 <code>AbstractQueuedSynchronizer</code> 类的基本原理、设计、实现、使用和性能。</p><p>论文地址：https://gee.cs.oswego.edu/dl/papers/aqs.pdf</p></blockquote><h2 id=摘要>摘要</h2><p>J2SE 1.5 版本的 <code>java.util.concurrent</code> 包中的大多数同步器（如：锁、屏障等）都是基于 <code>AbstractQueuedSynchronizer</code> 类的构建的框架构建的。该框架提供了常见的机制，用于原子地管理同步状态、阻塞和解除阻塞线程以及队列操作。本文介绍了该框架的基本原理、设计、实现、使用方法和性能。</p><h2 id=引言>引言</h2><p>Java 在发布的 J2SE-1.5 版本中引入了 <code>java.util.concurrent</code> 包，该包由 JCP 的 <a href=https://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf target=_blank rel="noopener noreferrer">JSR 166</a> 创建的一组并发支持类。其中包括一组同步器抽象数据类型，这些类维护内部同步状态（例如，表示锁是锁定还是解锁），提供更新和检查该状态的操作，并至少包含一个方法，该方法会阻塞调用的线程（如果同步状态要求阻塞），当其它线程更改同步状态以允许线程继续时，调用线程会恢复执行。示例包括各种形式的互斥锁（mutual exclusion locks）、读写锁（read-write locks）、信号量（semaphores）、屏障（barriers）、异步结果（future）、事件指示器（event indicators）和交接队列（handoff queues）。</p><p>众所周知，同步器可以用来实现其它任何的同步器。例如：可以使用可重入锁构建信号量，反之亦然。然而，通过此方式会导致系统较为复杂、开销大及不灵活，只能算是一种二流的工程选择。此外，从概念上来说，此方式也不具吸引力。如果这些结构之间没有比其它更为基础的，那么开发者就不应被迫选择其中一个构建其它的结构。相反，JSR166 构建了一个以 <code>AbstractQueuedSynchronizer</code> 类为中心的小框架，该框架提供了通用的机制，这些机制被包中的大多数同步器以及用户可能自行定义的类所使用。</p><p>本文的其余部分将讨论该框架的需求、设计和实现的主要思想、示例用法以及一些展示其性能特征的测量结果。</p><h2 id=需求>需求</h2><h3 id=功能>功能</h3><p>同步器有两种方法：至少一个 <code>acquire</code> 操作，该操作可以阻塞调用线程，除非/直到同步状态允许其执行；至少一个 <code>release</code> 操作，该操作可以改变同步状态，以便允许一个或多个被阻塞的线程解除阻塞。</p><p><code>java.util.concurrent</code> 包没有为同步器定义一个统一的 API。一些类是通过通用的接口定义的（如：<code>Lock</code>），但其它的仅包含特别的版本。因此，<code>acquire</code> 和 <code>release</code> 操作在不同类中使用了不同的名称。例如：<code>Lock.lock</code>、<code>Semaphore.acquire</code>、<code>CountDownLatch.await</code> 和 <code>FutureTask.get</code> 方法都映射到框架的 <code>acquire</code> 方法。然而，该包在各个类之间保持一致的约定，以支持一系列常见的使用选项。在有意义的情况下，每个同步器支持：</p><ul><li>非阻塞尝试获取同步状态（例如：<code>tryLock</code>）以及阻塞版本。</li><li>可选的超时，应用程序可放弃等待。</li><li>通过中断实现可取消性，通常分为一个可取消的 <code>acquire</code> 版本和一个不可取消的版本。</li></ul><p>取决于是否仅管理独占状态，同步器可能有所不同。<strong>独占</strong>：一次只有一个线程可以继续执行，直到可能的阻塞点；<strong>共享</strong>：多个线程至少有时可以继续执行。常规的锁需要维护独占状态，但计数信号量可能被多个线程获取，数量由计数值决定。为了广泛使用，该框架必须支持这两种操作模式。</p><p><code>java.util.concurrent</code> 包还定义了 <code>Condition</code> 接口，支持类似 monitor 的 <code>await</code> 和 <code>signal</code> 操作，通常与 <code>Lock</code> 类配合使用。</p><h3 id=执行目标>执行目标</h3><p>长期以来，Java 内置的锁（<code>synchronized</code>）一直存在性能问题。然而，这类工作的主要关注点是最小化空间开销（任何 Java 对象都可以作为锁）以及在主要是单线程的上下文中，针对单处理器的情况，最小化时间开销。对于同步器来说，这两点并不是特别重要的问题：程序员只有在需要时才会构造同步器，因此无需压缩本可能会浪费的空间；而且同步器几乎专门用于多线程设计（在多处理器系统上使用的频率越来越高），在这种情况下，偶尔会出现竞争的情况。因此，JVM 主要针对零竞争场景来优化锁，即假设大多数情况下没有多个线程竞争同一个锁。而将其它情况交给不太可预测的<strong>慢路径</strong>的策略上，这种策略并不适用于典型的多线程服务器应用程序，尤其是那些在 <code>java.util.concurrent</code> 库上高度依赖的应用。</p><p>此处的主要性能目标是<strong>可扩展性</strong>：即使同步器出现竞争，也要保持可预测的效率。理想情况下，无论有多少线程尝试通过同步点，所需的开销都应该是恒定的。主要目标之一是要最小化某个线程被允许通过同步点但尚未完成所花费的总时间。然而，这必须要与资源考虑因素取得平衡，包括总 CPU 时间需求、内存流量和线程调度开销。例如，自旋锁通常比阻塞锁消耗更短的获取时间，但通常会浪费 CPU 周期并产生内存竞争，所以通常情况下并不适用。</p><p>这些目标包含了两种使用风格。大多数应用程序应该最大化总吞吐量，不保证永不进入饥饿状态。然而，在资源控制等应用中，维护线程之间的访问公平性要重要得多，可以容忍较差的总体吞吐量。没有任何框架能够替用户在这些相互冲突的目标之间做出选择；相反，必须适应不同的公平性策略。</p><p>无论内部设计的多么精良，同步器也会在某些应用程序中造成性能瓶颈。因此，该框架必须能够对基本操作进行监控和检查，以便用户发现并缓解性能瓶颈。至少（也是最有用的）需要提供一种方法来确定有多少线程处于阻塞状态。</p><h2 id=设计和实现>设计和实现</h2><p>同步器背后的实现是非常简单的。</p><p><code>acquire</code> 操作如下：</p><pre tabindex=0><code>while (synchronization state does not allow acquire) {
    enqueue current thread if not already queued;
    possibly block current thread;
}
dequeue current thread if it was queued;
</code></pre><p><code>release</code> 操作如下：</p><pre tabindex=0><code>update synchronization state;
if (state may permit a blocked thread to acquire)
    unblock one or more queued threads;
</code></pre><p>支持这些操作需要三个基本组件配合：</p><ul><li>原子地管理同步状态</li><li>阻塞和解除阻塞线程</li><li>维护队列</li></ul><p>虽然理论上可以创建一个框架，让这三个部分能够独立变化。但是这样既不高效也不实用。例如，队列节点中存储的信息必须与解除阻塞所需的信息相对应，同时对外提供的方法的签名也要与同步状态的特性保持一致。</p><p>同步器框架的核心设计决策在于为这三个组件分别选择具体的实现方式，同时在使用方式上保持足够的灵活性。这种做法虽然有意限制了框架的适用范围，但在适用的场景中，它能提供足够高效的支持，使得几乎没有理由不使用该框架（而从头构建同步器）。</p><h3 id=同步状态>同步状态</h3><p><code>AbstractQueuedSynchronizer</code> 类仅使用单个 32 位的 <code>int</code> 维护同步状态并且提供了 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> 操作访问和更新此状态。这些方法依赖于 <code>java.util.concurrent.atomic</code> 包的支持，该包提供了符合 JSR133（Java 内存模型）的 <code>volatile</code> 语义来处理读写操作，并且能够访问底层的比较并交换（CAS）指令或者加载链接/条件存储（LL/SC）指令来实现 <code>compareAndSetState</code> 方法。此方法只有在状态值符合预期时，才会原子性地将状态设置为给定的新值。</p><p>将同步状态限制为一个 32 位的 <code>int</code> 是一个务实的决定。尽管 JSR166 提供了对于 64 位 <code>long</code> 属性的原子操作，但在许多平台上，这些操作仍然需要使用内部锁来模拟实现，这会导致同步器性能不佳。未来，可能会添加第二个专门用于 64 位状态的基类（使用 <code>long</code> 类型的控制参数）。然而，现在没有令人信服的理由将其添加在包里。当前，32 位对大多数应用来说已经足够。在 <code>java.util.concurrent</code> 同步器类中，只有 <code>CyclicBarrier</code> 需要更多位来维护状态，所以内部转而使用锁（就像包中的大多数高级工具一样）。</p><p>基于 <code>AbstractQueuedSynchronizer</code> 的具体类必须定义 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法，这些方法需要基于提供的状态方法来控制 <code>acquire</code> 和 <code>release</code> 操作。<code>tryAcquire</code> 方法在成功获取同步状态时必须返回 <code>true</code>，而 <code>tryRelease</code> 方法必须在新的同步状态允许将来的获取操作时返回 <code>true</code>。这些方法接受一个 <code>int</code> 类型的参数，可用于传达期望的状态；例如在可重入锁中，当从条件等待返回后重新获取锁时，用于重新建立递归计数。许多同步器并不需要这样的参数，因此会忽略它。</p><h3 id=阻塞>阻塞</h3><p>在 JSR166 之前，Java API 中没有可用的机制来阻塞和解除阻塞线程，以创建不基于内置 monitors 的同步器。唯一的候选是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，这些方法由于竞态问题导致无法使用：如果一个非阻塞线程在阻塞线程执行 <code>suspend</code> 前调用 <code>resume</code> 方法，<code>resume</code> 操作将不会产生任何效果。</p><p><code>java.util.concurrent.locks</code> 包中包含 <code>LockSupport</code> 类，可用于解决上述问题。<code>LockSupport.park</code> 阻塞当前线程，直到调用 <code>LockSupport.unpark</code>（虚假唤醒也是允许的）。对 <code>unpark</code> 的调用不会被计数，所以在一次 <code>park</code> 之前即使多次调用 <code>unpark</code>，也只会解除一次 <code>park</code> 的阻塞状态。此外，这种机制是基于每个线程而不是每个同步器。一个线程在新的同步器上调用 <code>park</code> 时，可能会因为之前使用时遗留的 <code>unpark</code> 状态而立即返回。但是，在没有调用 <code>unpark</code> 的情况下，下一次调用将会阻塞。虽然显式清除这个状态是可行的，但这样做并不值得。在必要时多次调用 <code>park</code> 反而更有效率。</p><p>这种简单的机制在某种程度上类似于 Solaris-9 线程库、WIN32 的可消费事件以及 Linux NPTL 线程库中使用的机制，因此可以在 Java 最常用的平台上高效地映射到这些机制上。然而，当前在 Solaris 和 Linux 上的 Sun Hotspot JVM 的实现实际上使用了 pthread 的条件变量（condvar），以便适配现有的运行时设计。<code>park</code> 方法还支持相对和绝对超时设置，并且与 JVM 的 <code>Thread.interrupt</code> 相结合，通过中断来<code>unpark</code> 一个线程。</p><h3 id=队列>队列</h3><p>此框架的核心为维护一个包含阻塞线程的队列，仅使用 FIFO 队列。因为此框架不支持基于优先级的队列同步器。</p><p>如今，人们普遍认同，对于同步队列来说，最适合的选择是使用不需要底层锁的非阻塞数据结构。在这些结构中，主要有两个候选方案：Mellor-Crummey 和 Scott（MCS）锁的变体，以及 Craig、Landin 和 Hagersten（CLH）锁的变体。从历史上看，CLH 锁仅用于自旋锁。然而，相比 MCS 锁而言，CLH 锁在同步框架中似乎更容易使用，因为它们更容易适应取消操作和超时处理，因此被选作基础方案。最终的设计与原始 CLH 结构有很大的不同，需要进一步解释。</p><p>CLH 队列并不太像一个典型的队列，因为它的入队和出队操作与其作为锁的用途紧密相关。它是一个通过两个可原子更新的字段（<code>head</code> 和 <code>tail</code>）来访问的链式队列，这两个字段最初都指向一个虚拟节点。</p><p><img src=/images/Java/AbstractQueuedSynchronizer/initial-queue.png alt></p><p>将 <code>node</code> 入队会使用原子操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>do</span> { pred <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>tail.<span style=color:#a6e22e>compareAndSet</span>(pred, node));
</span></span></code></pre></div><p>每个节点的释放状态都保存在其前驱节点中。因此，自旋锁的自旋操作看起来像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>while</span> (pred.<span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> RELEASED) ; <span style=color:#75715e>// spin</span>
</span></span></code></pre></div><p>在这个自旋操作之后的出队操作很简单，只需要将 <code>head</code> 字段设置为刚刚获取到锁的节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>head <span style=color:#f92672>=</span> node;
</span></span></code></pre></div><p>CLH 锁的优势包括：入队和出队操作快速、无锁、无阻塞（即使在争用情况下，总会有一个线程能在插入竞争中胜出从而取得进展）；检测是否有线程在等待也很快速（只需检查头指针是否等于尾指针）；并且释放状态是去中心化的，这样可以避免一些内存争用。</p></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2025, Leon Li.</div></footer></html>